-- MySQL dump 10.13  Distrib 8.0.30, for Win64 (x86_64)
--
-- Host: localhost    Database: maplesong
-- ------------------------------------------------------
-- Server version	8.0.30

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `hibernate_sequence`
--

DROP TABLE IF EXISTS `hibernate_sequence`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `hibernate_sequence` (
  `next_val` bigint DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb3 ROW_FORMAT=FIXED;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `hibernate_sequence`
--

LOCK TABLES `hibernate_sequence` WRITE;
/*!40000 ALTER TABLE `hibernate_sequence` DISABLE KEYS */;
/*!40000 ALTER TABLE `hibernate_sequence` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `content` longtext CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci,
  `create_time` datetime DEFAULT NULL,
  `first_picture` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `views` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `type_id` bigint DEFAULT NULL,
  `user_id` bigint DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `comment_count` int DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`) USING BTREE,
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (1,_binary '\0',_binary '','秋起\r\n\r\n今夜月亮似盘\r\n\r\n明月点缀着夜空\r\n\r\n繁星在一旁眨着眼睛\r\n\r\n微凉的秋风在敲打着窗\r\n\r\n也惊扰了我的梦\r\n\r\n秋雨携着秋风慢慢到来\r\n\r\n吹黄了一片片绿叶\r\n\r\n吹熟了一颗颗果实\r\n\r\n吹开了满坡的野菊\r\n\r\n也吹去了满天的乌云。\r\n\r\n一场秋雨一场凉\r\n\r\n散了初秋的余热\r\n\r\n雨变成露\r\n\r\n露又凝结成了霜\r\n\r\n在黄昏的夕阳下\r\n\r\n闪着碎银子的光\r\n\r\n一半皓白一半晶亮\r\n\r\n秋风柔情的吹着树木花草\r\n\r\n树上稠密的树叶\r\n\r\n轻轻摇着\r\n\r\n发出羞涩的低语\r\n\r\n好像在说\r\n\r\n谢谢你秋风\r\n\r\n让我有一个如此美妙的一天\r\n\r\n花草也频频点着头\r\n\r\n齐声说：对，对！真开心\r\n\r\n秋雨从立秋开始就时常光顾\r\n\r\n秋风也是\r\n\r\n有时秋风秋雨结伴而来\r\n\r\n有时又轮换着来\r\n\r\n秋风是主角，秋雨陪着它演\r\n\r\n一场秋天大戏就这样开始了……','2023-04-09 21:04:03','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282147530.jpg','原创',_binary '',_binary '\0',_binary '\0','秋起','2023-07-06 21:13:38','236',43,2,'秋起万物，落叶缤纷。',2),(2,_binary '\0',_binary '','### git常用指令\r\n\r\n1. 初始化仓库\r\n\r\n   ```apache\r\n   git init\r\n   ```\r\n2. 添加\r\n\r\n   ```apache\r\n   gid add .\r\n   ```\r\n3. 提交到本地仓库\r\n\r\n   ```apache\r\n   git commit -m \"介绍\"\r\n   ```\r\n4. 分支操作\r\n\r\n   ```apache\r\n   # 默认 分支名称为 master\r\n   # 列出所有本地分支\r\n   git branch\r\n   # 列出所有远程分支\r\n   git branch -r\r\n   # 列出所有本地分支和远程分支\r\n   git branch -a\r\n   # 创建分支\r\n   git branch <分支名>\r\n   # 切换分支\r\n   git checkout <分支名>\r\n   # 删除分支(如果分支已经修改过,则不允许删除)\r\n   git branch -d  <分支名>\r\n   # 强制删除分支\r\n   git branch -D  <分支名>\r\n   #主分支改名\r\n   git branch -M main\r\n\r\n   ```\r\n5. 远程仓库操作\r\n\r\n   ```apache\r\n   # 查看远程  列出指定的每一个远程服务器的简写\r\n   git remote\r\n   # 查看远程 , 列出 简称和地址\r\n   git remote  -v\r\n   # 查看远程仓库详细地址\r\n   git remote show  <仓库简称>\r\n   # 添加远程仓库\r\n   git remote add <shortname> <url>\r\n   # 移除远程仓库和本地仓库的关系(只是从本地移除远程仓库的关联关系，并不会真正影响到远程仓库)\r\n   git remote rm <shortname>\r\n   ```\r\n6. 推送代码\r\n\r\n   ```apache\r\n   # 将本地仓库推送至远程仓库的某个分支\r\n   git push [remote-name] [branch-name]\r\n\r\n   ```\r\n7. 克隆代码\r\n\r\n   ```apache\r\n   # 从远程仓库克隆\r\n   git clone <url>\r\n   # 从远程仓库拉取 (拉取到.git 目录,不会合并到工作区,工作区发生变化)\r\n   git fetch  <shortname>  <分支名称>\r\n   # 手动合并  把某个版本的某个分支合并到当前工作区\r\n   git merge <shortname>/<分支名称>\r\n   # 从远程仓库拉取 (拉取到.git 目录,合并到工作区,工作区不发生变化) = fetch+merge\r\n   git pull  <shortname>  <分支名称>\r\n   git pull  <shortname>  <分支名称>  --allow-unrelated-histories  #  强制拉取合并\r\n   ```\r\n8. 设置用户信息\r\n\r\n   ```apache\r\n   #设置用户信息\r\n      git config --global user.name “maple”\r\n      git config --global user.email “maple@maplesong.email”\r\n   #查看配置信息\r\n      git config --list\r\n      git config user.name\r\n   #通过上面的命令设置的信息会保存在~/.gitconfig文件中\r\n   ```','2023-04-12 22:31:37','https://img0.baidu.com/it/u=3284721806,1971816328&fm=253&fmt=auto?w=800&h=500','原创',_binary '',_binary '\0',_binary '\0','git基础指令','2023-05-01 22:17:55','119',44,2,'git常用指令记载',0),(4,_binary '\0',_binary '','## 基础指令\r\n1. 启动命令\r\n```shell\r\nstart nginx\r\n```\r\n\r\n2. 关闭命令\r\n```shell\r\nnginx -s stop\r\n```\r\n\r\n## conf文件配置\r\n&nbsp;&nbsp;&nbsp;&nbsp;此处直接给出本机文件配置，方便以后使用,其中主要是通过代理实现多个项目部署，并且配置了ssl证书，实现ssl加密.\r\n  ```apache\r\n\r\n#user  nobody;\r\nworker_processes  1;\r\n\r\n#error_log  logs/error.log;\r\n#error_log  logs/error.log  notice;\r\n#error_log  logs/error.log  info;\r\n\r\n#pid        logs/nginx.pid;\r\n\r\n\r\nevents {\r\n    worker_connections  1024;\r\n}\r\n\r\n\r\nhttp {\r\n    include       mime.types;\r\n    default_type  application/octet-stream;\r\n\r\n    #log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\r\n    #                  \'$status $body_bytes_sent \"$http_referer\" \'\r\n    #                  \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\r\n\r\n    #access_log  logs/access.log  main;\r\n\r\n    sendfile        on;\r\n    #tcp_nopush     on;\r\n\r\n    #keepalive_timeout  0;\r\n    keepalive_timeout  65;\r\n\r\n    #gzip  on;\r\n\r\n    server {\r\n        listen       80;\r\n        server_name  maplesong.club;\r\n        rewrite ^(.*)$ https://$host$1 permanent;\r\n\r\n        #charset koi8-r;\r\n\r\n        #access_log  logs/host.access.log  main;\r\n\r\n        # location / {\r\n        #     root   html;\r\n        #     index  index.html index.htm;\r\n        # }\r\n\r\n        # location /XiWei/ {\r\n        #     proxy_pass         http://maplesong.club:8889;\r\n        # }\r\n\r\n        # location /Maple/ {\r\n        #     proxy_pass         http://maplesong.club:8888;\r\n        # }\r\n\r\n        #error_page  404              /404.html;\r\n\r\n        # redirect server error pages to the static page /50x.html\r\n        #\r\n        # error_page   500 502 503 504  /50x.html;\r\n        # location = /50x.html {\r\n        #     root   html;\r\n        # }\r\n\r\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\r\n        #\r\n        #location ~ \\.php$ {\r\n        #    proxy_pass   http://127.0.0.1;\r\n        #}\r\n\r\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r\n        #\r\n        #location ~ \\.php$ {\r\n        #    root           html;\r\n        #    fastcgi_pass   127.0.0.1:9000;\r\n        #    fastcgi_index  index.php;\r\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\r\n        #    include        fastcgi_params;\r\n        #}\r\n\r\n        # deny access to .htaccess files, if Apache\'s document root\r\n        # concurs with nginx\'s one\r\n        #\r\n        #location ~ /\\.ht {\r\n        #    deny  all;\r\n        #}\r\n    }\r\n\r\n\r\n    server {  \r\n        listen 80;\r\n        server_name maple.maplesong.club;\r\n\r\n        rewrite ^(.*)$ https://$host$1 permanent;\r\n\r\n        # location / {\r\n        #     proxy_set_header   X-Real-IP $remote_addr;\r\n        #     proxy_set_header   Host      $http_host;\r\n        #     proxy_pass         http://maplesong.club:8888;\r\n        # }\r\n    }\r\n\r\n    server {\r\n        listen 80;\r\n        server_name xiwei.maplesong.club;\r\n\r\n        rewrite ^(.*)$ https://$host$1 permanent;\r\n\r\n        # location / {\r\n        #     proxy_set_header   X-Real-IP $remote_addr;\r\n        #     proxy_set_header   Host      $http_host;\r\n        #     proxy_pass         http://maplesong.club:8889;\r\n        # }\r\n    }\r\n\r\n\r\n\r\n    # another virtual host using mix of IP-, name-, and port-based configuration\r\n    #\r\n    #server {\r\n    #    listen       8000;\r\n    #    listen       somename:8080;\r\n    #    server_name  somename  alias  another.alias;\r\n\r\n    #    location / {\r\n    #        root   html;\r\n    #        index  index.html index.htm;\r\n    #    }\r\n    #}\r\n\r\n\r\n    # HTTPS server\r\n    #\r\n    server {\r\n       listen       443 ssl;\r\n       server_name  maplesong.club;\r\n\r\n       ssl_certificate      maplesong.club_bundle.pem;\r\n       ssl_certificate_key  maplesong.club.key;\r\n\r\n       ssl_session_cache    shared:SSL:1m;\r\n       ssl_session_timeout  5m;\r\n\r\n       ssl_ciphers  HIGH:!aNULL:!MD5;\r\n       ssl_prefer_server_ciphers  on;\r\n\r\n       location / {\r\n           root   html;\r\n           index  index.html index.htm;\r\n       }\r\n    }\r\n\r\n    server {\r\n        listen 443 ssl;\r\n        server_name maple.maplesong.club;\r\n\r\n        ssl_certificate      maple.maplesong.club_bundle.pem;\r\n        ssl_certificate_key  maple.maplesong.club.key;\r\n\r\n        ssl_session_cache    shared:SSL:1m;\r\n        ssl_session_timeout  5m;\r\n\r\n        ssl_ciphers  HIGH:!aNULL:!MD5;\r\n        ssl_prefer_server_ciphers  on;\r\n\r\n        location / {\r\n            proxy_set_header   X-Real-IP $remote_addr;\r\n            proxy_set_header   Host      $http_host;\r\n            proxy_pass         http://maplesong.club:8888;\r\n        }\r\n    }\r\n\r\n    server {\r\n        listen 443 ssl;\r\n        server_name xiwei.maplesong.club;\r\n\r\n        ssl_certificate      xiwei.maplesong.club_bundle.pem;\r\n        ssl_certificate_key  xiwei.maplesong.club.key;\r\n\r\n        ssl_session_cache    shared:SSL:1m;\r\n        ssl_session_timeout  5m;\r\n\r\n        ssl_ciphers  HIGH:!aNULL:!MD5;\r\n        ssl_prefer_server_ciphers  on;\r\n\r\n        location / {\r\n            proxy_set_header   X-Real-IP $remote_addr;\r\n            proxy_set_header   Host      $http_host;\r\n            proxy_pass         http://maplesong.club:8889;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n','2023-04-23 23:22:40','/images/picturebg.jpg','原创',_binary '',_binary '\0',_binary '\0','nginx基础指令以及conf文件配置','2023-04-28 21:59:20','45',46,2,'nginx使用的一些基础指令，以及如何配置conf文件实现多项目部署和ssl加密',0),(9,_binary '\0',_binary '','## 操作系统的历史\r\n了解即可，直接谷歌。\r\n## 学习目标\r\n- 多进程视图\r\n- 文件视图\r\n\r\n[![学习目标](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682738644666.jpg \"学习目标\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682738644666.jpg \"学习目标\")\r\n\r\n## cpu为什么采用并行方式\r\n1. 如果cpu只是不断取指执行，在读取IO时候需要等候很长的时间，和普通计算的计算时间大概是10^6的比值，所以不能采用这种静态执行的方式\r\n2. 为了让cpu 获得更高效率，所以采用并行执行的方式，将运行着的程序称为进程，于是引入多进程的概念\r\n\r\n## 进程和静态程序的区别\r\n概念上，进程=静态程序+不一样的东西\r\n- 进程有开始和结束\r\n- 进程会停止运行不断切换，对程序来说，停止切换没有意义,因为静态程序是一直往下运行，没有这种停止的概念\r\n- 进程需要保存ax,bx等信息\r\n\r\n## 多进程视图\r\n此节主要是为后面四个内容做一个宏观性的概括，包括下图四个内容\r\n\r\n[![多进程视图](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682841421491.jpg \"多进程视图\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682841421491.jpg \"多进程视图\")\r\n\r\n## 用户级线程\r\n- 有多少用户级线程就开多少个栈\r\n- 通过TCB与栈关联，同时在切换线程时，就是通过给当前栈指针cur赋值不同的TCB所对应的栈的指针,从而进行切换\r\n\r\n![线程切换](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682842664967.jpg \"线程切换\")\r\n\r\n- 线程创造及初始化\r\n\r\n![线程创造](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682842664968.jpg)\r\n\r\n## 核心级线程\r\n- 和用户级线程不同的是，其充分调动了内核，不再只是用户层面的线程\r\n- 有多少线程就开多少套栈，注意是套，代表一个内核栈和用户栈组合\r\n- 用户栈通过中断进入内核栈，在内核栈中需要保存用户栈的ss,sp,返回地址等信息，方便用户栈组成一套栈\r\n- 内核栈进行交换是采用内核里的TCB指针来进行切换，将TCB所对应的栈的指针赋值给cur指针即可完成切换\r\n![核心级线程](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682842357487.jpg \"核心级线程\")\r\n\r\n## 并行并发区别\r\n- 并行:同时开始，同时执行，采用不同的内存资源，运行在多核cpu或者多cpu上\r\n- 并发:同时开始，交替执行，采用相同的内存资源，运行在cpu的单核或者单核cpu上','2023-04-29 11:36:31','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682942037662.jpg','原创',_binary '',_binary '\0',_binary '\0','哈工大操作系统总结v0.2(操作系统后续学习概述)','2023-05-20 20:56:36','104',48,2,'操作系统的总结，持续更新ing',0),(5,_binary '\0',_binary '','## 题目\r\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\r\n\r\n**示例:**\r\n\r\n**输入**\r\n```apache\r\nmatrix = [[1,2,3],[4,5,6],[7,8,9]]\r\n```\r\n**输出**\r\n```apache\r\n[1,2,3,6,9,8,7,4,5]\r\n```\r\n\r\n## 题解思路\r\n针对这种模拟类型的题目，首先要确定是否需要控制条件，若需要则在模拟的外部先定好外部控制条件，若不需要，则不用设定外部控制条件，随后进行过程模拟，得出结果。\r\n针对本题，过程如下:\r\n1. 设定外部四个边界，above,below,right,left，用于控制模拟过程的返回以及终止。\r\n2. 利用while死循环模拟顺时针打印的过程，同时在循环中，需要对边界的值进行改变，如向下缩小一圈则above--，直到有边界越界，则结束循环，获取到所有的值存储在数组v中。\r\n\r\n### 代码如下\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int row;\r\n    int column;\r\n\r\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\r\n        vector<int> v;\r\n\r\n        if(matrix.empty())\r\n            return v;\r\n\r\n        int above = 0;\r\n        int below = matrix.size() - 1;\r\n        int left = 0;\r\n        int right = matrix[0].size() - 1; \r\n\r\n        while(true){\r\n            for(int i = left;i <= right;i++)\r\n                v.push_back(matrix[above][i]);\r\n            if(++above > below)\r\n                break;\r\n            for(int i = above;i <= below;i++)\r\n                v.push_back(matrix[i][right]);\r\n            if(--right < left)\r\n                break;\r\n            for(int i = right;i >= left;i--)\r\n                v.push_back(matrix[below][i]);\r\n            if(--below < above)\r\n                break;\r\n            for(int i = below;i >= above;i--)\r\n                v.push_back(matrix[i][left]);\r\n            if(++left > right)\r\n                break;\r\n        }\r\n        return v;\r\n    }\r\n};\r\n```\r\n\r\n## 一点感悟\r\n在我看来,其实递归,dfs,模拟本质上是有关系的,他们的关系大致如下:\r\n\r\n![模拟关系图](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/moni01.jpg)\r\n\r\n','2023-04-24 09:40:37','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/picture.jpg','原创',_binary '',_binary '',_binary '\0','剑指29题顺时针打印矩阵题解','2023-06-25 21:38:59','194',47,2,'剑指offer29题顺时针打印矩阵的题解以及如何处理这种类似的模拟题目的步骤操作。',0),(7,_binary '\0',_binary '','## 递归实现\r\n### 先序遍历\r\n```cpp\r\nvoid PreTravel(BinTree T){\r\n        if(!T)\r\n           return;\r\n        cout << bt << \" \";\r\n        PreTravel(T->left);\r\n        PreTravel(T->right);\r\n}\r\n```\r\n### 中序遍历\r\n```cpp\r\nvoid PreTravel(BinTree T){\r\n        if(!T)\r\n           return;\r\n        PreTravel(T->left);\r\n		cout << bt << \" \";\r\n        PreTravel(T->right);\r\n}\r\n```\r\n### 后序遍历\r\n```cpp\r\nvoid PreTravel(BinTree T){\r\n        if(!T)\r\n           return;\r\n        PreTravel(T->left);\r\n        PreTravel(T->right);\r\n		cout << bt << \" \";\r\n}\r\n```\r\n## 非递归实现\r\n### 先序遍历\r\n```cpp\r\n#define Null -1\r\n\r\ntypedef struct tnode{\r\n    char data;\r\n    int left = -1;\r\n    int right = -1;\r\n}*BinTree,tree;\r\n\r\nvoid PreTravel(BinTree T,int bt){\r\n    stack s = new snode();\r\n    init(s);\r\n    int temp;\r\n    while(bt != Null || !(s->top == -1)){\r\n        while(bt != Null){\r\n			cout << bt << \" \";\r\n            push(s,bt+\'0\');\r\n            bt = T[bt].left;\r\n        }\r\n        bt = pop(s) - \'0\';\r\n        bt = T[bt].right;\r\n    }\r\n    delete s;\r\n}\r\n```\r\n### 中序遍历\r\n```cpp\r\nvoid InTravel(BinTree T,int bt){\r\n    stack s = new snode();\r\n    init(s);\r\n    int temp;\r\n    while(bt != Null || !(s->top == -1)){\r\n        while(bt != Null){\r\n            push(s,bt+\'0\');\r\n            bt = T[bt].left;\r\n        }\r\n        bt = pop(s) - \'0\';\r\n        cout << bt << \" \";\r\n        bt = T[bt].right;\r\n    }\r\n    delete s;\r\n}\r\n```\r\n### 后序遍历\r\n```cpp\r\nvoid PoTravel(BinTree T,int bt){\r\n    stack s = new snode();\r\n    init(s);\r\n    int temp;\r\n    int check[10] = {0};\r\n    while(bt != Null || !(s->top == -1)){\r\n        while(bt != Null){\r\n            push(s,bt+\'0\');\r\n            bt = T[bt].left;\r\n        }\r\n        bt = pop(s) - \'0\';\r\n        check[bt]++;\r\n        if(check[bt] == 1)\r\n            push(s,bt+\'0\');\r\n        else if(check[bt] == 2)\r\n            cout << bt << \" \";\r\n        bt = T[bt].right;\r\n    }\r\n    delete s;\r\n}\r\n```\r\n## 总结\r\n递归实现比较简单，而非递归实现主要是通过栈来实现，其中前序和中序需要入栈一次，而后序遍历需要入栈两次\r\n','2023-04-28 20:58:27','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282147110.png','原创',_binary '',_binary '\0',_binary '\0','二叉树的三种遍历的递归和非递归实现','2023-04-28 21:55:17','42',49,2,'二叉树遍历的递归实现和非递归实现',0),(8,_binary '\0',_binary '','## 引导过程\r\n首先进入bios，随后读取第一个扇区，到0x70位置，再将该段的位置搬移到0x90的位置，随后读取之后的四个扇区，再将操作系统读入0x00的位置，之后，便开始执行操作系统，通过取指译码执行的操作不断取指执行，让操作系统跑起来。\r\n\r\n[![启动过程](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124001.jpg \"启动过程\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124001.jpg \"启动过程\")\r\n\r\n## 系统接口\r\n主要是一些可以跟内核打交道的函数，如fetch,write,read等称为系统接口。\r\n\r\n[![系统接口](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124250.jpg \"系统接口\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124250.jpg \"系统接口\")\r\n\r\n## 系统接口实现\r\n主要是通过0x80这个中断，但在中断之前需要先令eax=系统调用号，在中断执行时，对int 0x80的初始化sched_init中,令DPL=3，从而让CPL=3的应用程序得以执行该中断，随后在IDT中赋值，此时让CS= 8 则 CPL=0(获得内核权),随后在中断处理程序system_call中通过eax在sys_call_table找到执行对应内核程序的位置，从而执行对应的内核程序。\r\n\r\n[![系统接口实现](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124918.jpg \"系统接口实现\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124918.jpg \"系统接口实现\")\r\n\r\n[![系统接口实现](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124263.jpg \"系统接口实现\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282124263.jpg \"系统接口实现\")\r\n\r\n[![系统接口实现](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282125847.jpg \"系统接口实现\")](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282125847.jpg \"系统接口实现\")','2023-04-28 21:31:31','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282134748.png','原创',_binary '',_binary '\0',_binary '\0','哈工大操作系统总结v0.1(操作系统如何立起来)','2023-05-02 20:45:33','58',48,2,'哈工大操作系统的一些理解',0),(10,_binary '\0',_binary '','## 思路一 ：滑动窗口（双指针）\r\n题目中要求答案必须是**子串**的长度，意味着子串内的字符在原字符串中一定是连续的。因此我们可以将答案看作原字符串的一个**滑动窗口**，并维护窗口内**不能有重复字符**，同时更新窗口的**最大值**。\r\n\r\n![滑动窗口](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304302219826.png \"滑动窗口\")\r\n\r\n## 算法\r\n- 初始化头尾指针 head，tail；\r\n- tail 指针右移，判断 tail 指向的元素是否在 [head:tail] 的窗口内；\r\n- 如果窗口中没有该元素，则将该元素加入窗口，同时更新窗口长度最大值res，tail 指针继续右移；\r\n- 如果窗口中存在该元素，则将 head 指针右移，直到窗口中不包含该元素。\r\n- 此处可以利用**哈希表优化head指针**，即用哈希表存储各个字符对应的原来的存储位置temp，根据temp是否比head大，则可知当前tail指向元素是否在滑动窗口之中，若在，则将head更新为temp,若不在，则直接取head,即**max(head,temp)**,同时要记得更新索引temp\r\n- 返回窗口长度的最大值res。\r\n\r\n## 代码\r\n- cpp\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int i = -1,res = 0;\r\n        unordered_map<char,int> map;\r\n        for(int j = 0;j < s.size();j++){\r\n            if(map.count(s[j]) != 0){\r\n                i = max(i,map[s[j]]);\r\n            }\r\n            map[s[j]] = j;\r\n            res = max(res,j-i);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int i = -1,res = 0;\r\n        Map<Character,Integer> map = new HashMap<>();\r\n        for(int j = 0;j < s.length();j++){\r\n            if(map.containsKey(s.charAt(j))){\r\n                i = Math.max(i,map.get(s.charAt(j)));\r\n            }\r\n            map.put(s.charAt(j),j);\r\n            res = Math.max(res,j-i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n##思路二 : 动态规划\r\n- 思路如下\r\n\r\n![动态规划](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304302233264.png)\r\n\r\n## 总结\r\n滑动窗口非常适用于子串类的各种问题，需要好好的反复掌握，理解其中的原理,对此题，也可以使用双指针，动态规划来进行解题，事实上，双指针和滑动窗口在本题实质上是一样的，动态规划需要根据迭代关系，即判断字符所在原来的索引是否比当前左边界i大，若大，则需要更新dp[j] = j-i,否则dp[j] = dp[j-1]+1\r\n\r\n\r\n\r\n','2023-04-30 22:36:35','https://picx.zhimg.com/80/v2-d024c6ad6851b266e8509d1aa0948ceb_1440w.webp?source=1940ef5c','原创',_binary '',_binary '\0',_binary '\0','剑指 Offer 48. 最长不含重复字符的子字符串','2023-04-30 23:00:00','88',47,2,'剑指 Offer 48. 最长不含重复字符的子字符串,涉及滑动窗口，双指针，动态规划，是滑动窗口思想很好的体现',0),(11,_binary '\0',_binary '','## 核心线程实现实例\r\n\r\n 此处主要分为线程切换五部曲以及**threadCreate**和如何执行指令\r\n\r\n#### 线程切换五部曲\r\n\r\n- 中断入口和中断出口\r\n中断入口咋此处就是常规的中断进入，不赘述\r\n\r\n![中断入口](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801623.jpg)\r\n\r\n- schedule和中断出口\r\n**schedule**是调度，后续会讲述，而中断出口在此处也较为简单，显然就是弹栈即可\r\n\r\n![中断出口](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801671.jpg)\r\n\r\n- switch_to(切换过程)\r\n1. 此处的切换过程，没有采用栈来弹出epi，从而返回切换的那种操作，而是采用的TSS，指令比较简单，但是时间较为繁琐，在后续的linux系统中，都不再使用此操作了，都改为使用栈来进行切换\r\n2. 需要注意的是TSS的切换是将CPU中的内容先拍给原来进程的TSS，再将新进程的TSS的内容赋值进CPU,同时让TR指向当前的TSS的描述符(即指针,具体见图)\r\n\r\n![切换过程](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801570.jpg)\r\n\r\n#### threadCreate\r\n- 在此处中，主要是为fetch如何创建进程的源码进行了分析，创建进程，主要是通过拷贝来创建的，在拷贝的过程中，为新的进程创建新的内核栈，但是其用户栈还是和父进程是相同的，这是因为此时还未给新创建的进程分配指令，待到后面利用exec时，便会有对应的子进程的用户栈创建了\r\n- 需要注意的在父进程创建好子进程之后，还是继续执行父进程，直到父进程阻塞，则开始调度，调度到新建的子进程时，其会返回到创建该进程的pc指针的位置，返回值为0，从而执行exec，为该进程分配任务，创建用户栈，从而开始执行任务\r\n\r\n![threadCreate](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801699.jpg)\r\n\r\n![copy](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801749.jpg)\r\n\r\n![copy](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801781.jpg)\r\n\r\n#### exec(如何执行指令)\r\n- 使用**exec**指令后，会调用**int 0x80**指令,中断进入后，通过**sys_called**找到对应的执行的内核函数**sys_execve**,**在该函数中将对应的所需执行任务的指针赋值给epi**,即可让线程执行对应的指令\r\n- 需要注意的是,epi是通过esp+0x1C计算得到的,而epi的含义是对应的栈中保存返回指令指针的位置,通过赋值epi,即可让中断返回后,线程可以执行用户所给定的任务\r\n\r\n![exec](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801838.jpg)\r\n\r\n![exec](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801869.jpg)\r\n\r\n![exec](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801913.jpg)\r\n\r\n####总结\r\n![总结](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801948.jpg)\r\n\r\n## 操作系统的那颗树\r\n\r\n此篇内容主要是对之前的操作系统cpu调度中进程的多进程的实现进行了一个复习和总结，理清楚其中的大概思路\r\n\r\n## cpu调度策略\r\n\r\n调度策略有以下三个影响因素\r\n- 周转时间\r\n- 响应时间\r\n- 系统内耗\r\n\r\n![调度](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801997.jpg)\r\n\r\n为了解决这三个问题，并且让矛盾最小化,提出了不同的调度策略，有短任务优先，轮播调度，优先级调度等方法，但是都各有优缺点，以下分别列出\r\n\r\n- 短任务优先\r\n\r\n  该策略可以让**周转时间最小化**，根据图中公式推导即可得\r\n\r\n![调度](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801048.jpg)\r\n\r\n- 轮播调度\r\n\r\n  该策略可以让**响应时间得到控制**，不会一直等待响应，从而造成不好的体验\r\n  \r\n![调度](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801093.jpg)\r\n\r\n- 优先级调度\r\n\r\n  通过设置**优先级**，来决定调度，需要让优先级能根据情况来进行改变，否则容易出问题\r\n  \r\n![优先级调度](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011931277.jpg)\r\n\r\n![优先级调度](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011932014.jpg)\r\n\r\n## 实际的schedule\r\n**linux0.11**中**schedule**的调度策略是折中的，非常值得借鉴和思考，其具体实现如下，包括其中用来调度的变量**counter**的作用也进行了总结\r\n\r\n- 源码\r\n\r\n![源码](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801122.jpg)\r\n\r\n- counter作用\r\n\r\n**时间片**\r\n\r\n![时间片](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801164.jpg)\r\n\r\n**优先级**\r\n\r\n![优先级](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801195.jpg)\r\n\r\n**作用总结**\r\n\r\n![总结](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011801245.jpg)','2023-05-01 18:30:11','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011943676.jpg','原创',_binary '',_binary '\0',_binary '\0','哈工大操作系统总结v0.3(进程间切换的实现)','2023-05-02 20:44:46','113',48,2,'哈工大操作系统持续更新ing，此篇涉及核心线程切换，ThreadCreate如何创建线程，如何让线程实现指令，以及cpu调度策略等内容',0),(12,_binary '\0',_binary '','## 题意\r\n\r\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\r\n示例:\r\n```apache\r\n输入: [7,5,6,4]\r\n输出: 5\r\n```\r\n## 思路\r\n- 解决此题主要是利用稳定排序的逆序对的对数的统计，即可知道对应的数组的逆序对，而在稳定排序中，归并排序最快，故选择归并排序来进行统计\r\n\r\n## 题解代码\r\n\r\n- cpp\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int reversePairs(vector<int>& nums) {\r\n        vector<int> tmp(nums.size());\r\n        return mergeSort(0,nums.size()-1,nums,tmp);\r\n    }\r\n\r\n    int mergeSort(int l,int r,vector<int>& nums,vector<int>& tmp){\r\n        if(l >= r)\r\n            return 0;\r\n        int m = (l+r)/2;\r\n        int res = mergeSort(l,m,nums,tmp) + mergeSort(m+1,r,nums,tmp);\r\n        int i = l;\r\n        int j = m+1;\r\n        for(int k = l;k <= r;k++){\r\n            tmp[k] = nums[k];\r\n        }\r\n        for(int k = l;k <= r;k++){\r\n            if(i == m+1){\r\n                nums[k] = tmp[j++];\r\n            }\r\n            else if(j == r+1 || tmp[i] <= tmp[j]){\r\n                nums[k] = tmp[i++];\r\n            }\r\n            else if(tmp[i] > tmp[j]){\r\n                res += m-i+1;\r\n                nums[k] = tmp[j++];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    int[] nums;\r\n    int[] tmp;\r\n\r\n    public int reversePairs(int[] nums) {\r\n        this.nums = nums;\r\n        tmp = new int[nums.length];\r\n        return mergeSort(0,nums.length-1);\r\n    }\r\n\r\n    int mergeSort(int l,int r){\r\n        if(l >= r){\r\n            return 0;\r\n        }\r\n        int m = (l+r)/2;\r\n        int res = mergeSort(l,m) + mergeSort(m+1,r);\r\n        int i = l;\r\n        int j = m+1;\r\n        for(int k = l;k <= r;k++){\r\n            tmp[k] = nums[k];\r\n        }\r\n        for(int k = l;k <= r;k++){\r\n            if(i == m+1){\r\n                nums[k] = tmp[j++];\r\n            }\r\n            else if(j == r+1 || tmp[i] <= tmp[j]){\r\n                nums[k] = tmp[i++];\r\n            }\r\n            else{\r\n                res += m-i+1;\r\n                nums[k] = tmp[j++];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```','2023-05-01 22:11:31','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682950263182.jpg','原创',_binary '',_binary '\0',_binary '\0','剑指 Offer 51. 数组中的逆序对','2023-06-25 21:33:39','117',47,2,'一道稳定排序统计逆序对的题目，在此题为了时间复杂度更小，故采用归并排序来进行统计，此题中归并排序的模板值得记住，其实质就是递归，并且在递归回来进行处理，也称合并处理，和树的后序遍历类似，值得深思',0),(13,_binary '\0',_binary '','## 引言\r\n在之前的内容中便已经提到过,多进程视图有四个部分，如下图所示，而此篇主要就是叙述进程间如何进行合作，即有关信号量的概念以及原理\r\n\r\n![多进程视图](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682841421491.jpg)\r\n\r\n## 进程同步及信号量概念\r\n\r\n#### 概念\r\n让进程走走停停来保证多进程合作的有序\r\n\r\n![信号量](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022019248.jpg)\r\n\r\n#### 信号实现同步及其局限性\r\n\r\n- 可以通过信号实现**进程的同步**，如使用count的满或不满来传递信号\r\n- 使用信号实现同步会具有**局限性**，只能粗略的控制进程同步，比如在此处如下图中，有**两个进程阻塞**的情况下，信号只能控制到一个进程唤醒，而**另外一个睡眠的进程便会被遗忘**，这就是信号的局限\r\n- 由于信号的局限，于是后续便引出了信号+量纲来实现的信号量，其可以细化的控制进程同步\r\n\r\n![信号](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022019279.jpg)\r\n\r\n#### 引入信号量来实现进程同步\r\n- 由于信号的局限，于是引入信号量,其一般由一个整数数值来进行表示，给其赋予一定的意义之后，便可以实现进程同步，并且能够**细化的控制进程**，**不会出现信号的局限性**\r\n- 在下面的例子中，以**value**为信号量记载资源个数,**当value小于0时**，代表资源使用完，进程如果此时需要资源，则直接阻塞，使得进程休眠，同时**value--**，其对应的含义便是**|value|**个进程**阻塞**，因此也可以通过Value是否为负值，来决定是否**唤醒**阻塞的进程，从而**实现进程的休眠唤醒**，进而实现了**进程间的同步**\r\n\r\n![信号量](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022019316.jpg)\r\n\r\n#### 示列使用\r\n以下给出信号量的一个具体使用，了解其用处\r\n\r\n![示列](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022019357.jpg)\r\n\r\n## 临界区\r\n\r\n#### 临界区的由来\r\n\r\n![临界区](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305031955604.jpg)\r\n\r\n#### 临界区代码保护原则\r\n\r\n![临界区](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305031956902.jpg)\r\n\r\n#### 临界区的实现方法\r\n\r\n1. 软件层面\r\n- 轮换法(有缺陷)\r\n\r\n	两个进程执行时 ，可能让一个变量被重复操作，于是引出标记法，具体缺陷原因见视频\r\n\r\n![轮换法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032007948.jpg)\r\n- 标记法(会造成死锁)\r\n\r\n![标记法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032009579.jpg)\r\n![标记法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032010855.jpg)\r\n- 非对称标记法(结合轮换和标记法)\r\n\r\n![非对称标记法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032013489.jpg)\r\n![非对称标记法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032014708.jpg)\r\n- 面包店算法(对于多个进程提出的算法)\r\n\r\n![面包店算法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032016366.jpg)\r\n![面包店算法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032016799.jpg)\r\n2. 硬件层面\r\n- 关闭中断(只使用于一个cpu单核)\r\n\r\n![关闭中断](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032019122.jpg)\r\n- 硬件原子指令法(普遍适用)\r\n\r\n	通过硬件，将锁的语句变成一条原子指令来执行，继而可以直接锁，不会被切断\r\n\r\n![硬件原子指令](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032019964.jpg)\r\n\r\n- 实际运用\r\n\r\n![实际运用](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032028503.jpg)\r\n#### linux如何实现临界区\r\n此处的重点主要在于队列如何构成，比较难以理解，注意tmp在内核栈中即可知道，可以直接通过tmp索引下一个pcb,而此处的唤醒也需要注意是全部唤醒，让进程重新根据优先级竞争\r\n\r\n![linux](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032024001.jpg)\r\n![linux](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032024654.jpg)\r\n![linux](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032024066.jpg)\r\n## 死锁\r\n\r\n概念:多个进程由于等待对方持有的资源而造成谁都无法执行的情况称为死锁\r\n\r\n#### 死锁的起因\r\n\r\n![起因](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032029429.jpg)\r\n\r\n#### 死锁的必要条件\r\n\r\n![必要条件](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032029342.jpg)\r\n\r\n#### 死锁的四种解决方法\r\n\r\n![解决方法](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032029366.jpg)\r\n\r\n- 死锁预防\r\n\r\n![死锁预防](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032033823.jpg)\r\n\r\n- 死锁避免\r\n\r\n![避免](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032033865.jpg)\r\n![避免](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032033667.jpg)\r\n![避免](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032033707.jpg)\r\n- 死锁检测(回滚进程)\r\n\r\n![死锁检测](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032033741.jpg)\r\n- 死锁忽略(windows,linux使用)\r\n\r\n![死锁忽略](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305032033780.jpg)','2023-05-02 20:42:40','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022024919.png','原创',_binary '',_binary '\0',_binary '\0','操作系统v0.4(进程间如何进行合作--信号量)','2023-05-03 20:43:00','110',48,2,'多进程视图中，操作系统的进程如何进行合作，即有关信号量的原理和实践概念',1),(14,_binary '\0',_binary '','## 题意\r\n\r\n统计一个数字在排序数组中出现的次数。\r\n\r\n## 示例\r\n\r\n```apache\r\n输入: nums = [5,7,7,8,8,10], target = 8\r\n输出: 2\r\n```\r\n\r\n## 思路\r\n- 主要是利用二分查找，先查找对应的target的上界j，再查找其第一次出现的位置i,则j-i即为target出现的次数\r\n- 需要注意的是，查找第一次出现的位置，可以通过查找target-1的上界来得到\r\n\r\n## 代码\r\n- cpp\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int search(vector<int>& nums, int target) {\r\n        return upper_bound(nums.begin(),nums.end(),target) - lower_bound(nums.begin(),nums.end(),target);\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    public int search(int[] nums, int target) {\r\n        return helper(nums,target) - helper(nums,target-1);\r\n    }\r\n\r\n    int helper(int[] nums,int target){\r\n        int i = 0;\r\n        int j = nums.length - 1;\r\n        while(i <= j){\r\n            int m = (i+j)/2;\r\n            if(nums[m] > target){\r\n                j = m-1;\r\n            }\r\n            else{\r\n                i = m+1;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n}\r\n```\r\n\r\n## 总结\r\n1. **对于查找时，要分target是否在数组中,若不在数组中，显然根据二分查找的算法规律，最后i为上界,j为下届,而若是target在数组中,则情况如下**\r\n\r\n	- **其中查找上界和下届主要是在原来二分查找时，在查找到等于target的地方进行修改，如果想查上界，就让i=m+1,人为的让相等的时候，不返回值，而是继续往右边查，这样查下去，最后必然使得i == j，而此时只需判断是大于target还是==target，两种情况操作完，都可使得i指向target的上界,而对于查找下届，让j=m-1即可**\r\n	- **查上届,i最后为上届,j为target最后出现的位置**\r\n	- **查下届,j最后为下届,i为target第一次出现的位置**\r\n\r\n2.  **此题中涉及到了二分查询上界，其稍微改改即可查询下届以及对应的target，此查找模板极为重要,需要仔细记住**','2023-05-02 22:17:30','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022216520.jpg','原创',_binary '',_binary '\0',_binary '\0','剑指 Offer 53 - I. 在排序数组中查找数字 I','2023-05-02 22:49:17','106',47,2,'二分查询模板题，此题中通过查询上下届，来查询有序数组中，出现的对应值target的个数',0),(15,_binary '\0',_binary '','## 引言\r\n在之前的内容中便已经提到过,多进程视图有四个部分，如下图所示，而此篇主要就是叙述进程间内存如何管理\r\n\r\n![多进程视图](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682841421491.jpg)\r\n\r\n## 内存使用\r\n\r\n### 概念\r\n\r\n![概念](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041723781.jpg)\r\n\r\n### 相对地址以及重定位\r\n由于使用绝对地址会有问题，故引出相对地址,而实现相对地址需要进行重定位，针对于重定位有三种方式，操作系统使用的是其中的运行时重定位，另外两种重定位方式理解其由来即可\r\n\r\n1. 问题引出\r\n\r\n	问题的原因在于使用物理地址，内存是可以使用了，但是无法正确访问地址\r\n\r\n![问题](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041725747.jpg)\r\n\r\n2. 解决问题(重定位)\r\n\r\n	为了解决无法正确访问地址的问题，故引出三种重定位的方式来进行地址修改，分别是以下三种重定位方式\r\n- 编译时重定位(编译时确定对应位置)\r\n- 载入时重定位(载入时确定对应位置)\r\n- 运行时重定位(最好的方式,可以随机应变)\r\n\r\n#### 编译或载入时重定位\r\n\r\n![问题](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041725726.jpg)\r\n\r\n#### 为何不采用编译或载入时重定位\r\n**原因**:因为现代操作系统，在程序载入后，进程是需要在内存和磁盘进行交换的，而编译或载入时重定位，**放入内存之后，如果和磁盘进行交换了之后，再度放入内存进行运行，对应的进程访问地址会出错**\r\n\r\n![原因](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041723970.jpg)\r\n\r\n#### 运行时重定位\r\n- 将基地址存入pcb中，从而实现运行时重定位，可以完美解决内存和磁盘交换之后访问出错的问题，故现代操作系统采用的都是运行时重定位\r\n- 在进程切换时，根据pcb切换基地址，即可正常运行下一个进程\r\n\r\n![运行时重定位](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041723224.jpg)\r\n![切换](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041747951.jpg)\r\n\r\n## 分段载入内存(载入方式)\r\n- 由于程序整段放入内存，不符合程序员平常编写程序逻辑，并且之后在内存之中处理也不方便，故采用分段处理，这样在一个段移动时，其余段还可以正常执行，不会出现全部都不能执行的情况，这是相比整段放入内存的优势\r\n- 由于进行了分段，故要从单个程序地址转变成，为每个段都给定一个短基址，并且将基址存入pcb中，当进程需要切换段时，根据基址进行切换即可\r\n\r\n![分段](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041747612.jpg)\r\n![分段](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041747294.jpg)\r\n\r\n## 内存分割\r\n\r\n### 固定分区\r\n\r\n![固定分区](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041914845.jpg)\r\n\r\n### 可变分区\r\n\r\n![可变分区](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041914564.jpg)\r\n\r\n#### 释放内存\r\n\r\n![释放内存](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041915342.jpg)\r\n\r\n#### 申请内存\r\n- 首先适配较为随机\r\n- 最佳适配，分配下去容易造成细碎的内存\r\n- 最差内存，分配之后，最后会较为均匀\r\n\r\n![申请内存](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041915378.jpg)\r\n\r\n#### 可变分区造成的问题\r\n\r\n![问题](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041915777.jpg)\r\n\r\n### 分页\r\n\r\n#### 概念(从连续到离散)\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041919780.jpg)\r\n\r\n#### 如何索引物理地址\r\n用页表索引对应物理地址即可，但是页表特别大，内存的使用率低，故需要改进\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041920929.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041924212.jpg)\r\n\r\n#### 改进的第一种尝试\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041922690.jpg)\r\n\r\n#### 改进的第二种尝试（多级目录）\r\n- 概念\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041923578.jpg)\r\n- 缺陷以及改进\r\n由于多级页表在时间上会耗费较多时间，于是使用快表TLB对其优化，对经常使用的地址进行存储，从而快速找到对应的内存\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041925102.jpg)\r\n- TCB(快表)得以发挥作用的原因\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041925624.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305041925136.jpg)\r\n\r\n','2023-05-04 18:11:46','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022216283.jpg','原创',_binary '',_binary '\0',_binary '\0','操作系统v0.5(进程间内存如何管理)','2023-05-05 23:10:14','118',48,2,'操作系统间的内存是如何管理的，内存分段分区分页，以及多级目录和快表的相关知识以及概念总结',0),(16,_binary '\0',_binary '','## 引言\r\n此篇承接操作系统v0.5的内容，是对应上篇内容的续集，主要还是描述内存管理部分的内容，但此篇主要涉及三个部分，分别如下\r\n- 段页实际操作\r\n- 内存换入（**请求调页**）\r\n- 内存换出\r\n\r\n## 段页实际操作\r\n\r\n段页实际操作主要是通过虚拟内存来实现\r\n\r\n#### 问题引出\r\n主要是说明段和页如何组合在一起使用，而这其中的关键便是虚拟内存\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052314434.jpg)\r\n\r\n#### 问题解决(虚拟内存)\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052315313.jpg)\r\n\r\n#### 虚拟内存引入后，如何重定位\r\n\r\n思路:一级一级的索引即可\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052317847.jpg)\r\n\r\n#### 虚拟内存引入后，如何载入内存\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052319561.jpg)\r\n\r\n#### 虚拟内存引入后，如何内存管理\r\n\r\n具体见下图连续的重点，如有疑惑，回去看视频\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052324909.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052325447.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052325356.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052326279.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052326656.jpg)\r\n\r\n## 内存换入换出\r\n\r\n#### 概念引出\r\n\r\n对于用户来说，只看见虚拟内存，而物理内存如何分配对用户是隐藏的，故当实际内存小于虚拟内存时，为了让用户依旧得到虚拟内存大小的内存体验，需要通过磁盘与物理内存进行换入换出，从而动态的交换内存，为用户实现虚拟内存大小的体验\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052327919.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052327831.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052333605.jpg)\r\n\r\n#### 请求调页逻辑概念实现\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052332747.jpg)\r\n\r\n#### 请求调页实际实现\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052334079.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052334389.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052334364.jpg)\r\n\r\n#### 内存换出概念引出\r\n因为内存无法一直分配，故当内存达到一定限度时，必须要选择页对应的内存进行淘汰,从而维持系统的进行以及内存的使用,而淘汰方式主要有三种,分别如下,后续会进行介绍\r\n- FIFO\r\n- MIN\r\n- LRU\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052336177.jpg)\r\n\r\n#### 内存换出方法\r\n- FIFO\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052339906.jpg)\r\n- MIN\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052340156.jpg)\r\n- LRU\r\n\r\n**算法思想如下**\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052341662.jpg)\r\n\r\n**准确实现如下,分别由时间戳以及页码栈实现**\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052342540.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052342297.jpg)\r\n\r\n**近似实现如下,目前使用的是经过优化的近似实现即最后所给出的实现方法**\r\n\r\n- 通过循环队列来模拟最近访问的页，即可近似实现**LRU**，而最初的模拟会有**一个问题**，那就是当**缺页很少时，其实循环队列保存的是长期的页的访问结果，不是最近的页的访问内容**，这样就会将算法退化为**FIFO**\r\n- 解决上面提到的问题，只需要**再利用一个指针，在一定规定时间内，定时清除对应页的R位**，这样**最后页的R位保留的就是最近的数据**，也就能模拟**LRU**\r\n- 值得注意的是，**清除指针速度要快，而淘汰指针速度要慢**\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052345136.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052345953.jpg)\r\n\r\n## 给线程分配多少页框合适\r\n见下图即可\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052346584.jpg)\r\n\r\n## 总结\r\n将内存的换入换出结合是为虚拟内存服务，而虚拟内存是为段页结合服务，段页结合是为程序服务，程序最终又会成为进程，如此便将进程与内存管理联系起来，形成一幅进程带动内存使用的多进程图像\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305052346678.jpg)','2023-05-05 23:55:22','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022216311.jpg','原创',_binary '',_binary '\0',_binary '\0','操作系统v0.6(段页实际操作及内存换入换出)','2023-05-05 23:58:27','116',48,2,'内存管理中的内存换入换出，以及段页的实际使用的相关内容',0),(17,_binary '\0',_binary '','## 引言\r\n 在v0.2中提过操作系统主要包括多进程视图以及文件视图，此篇主要描述的便是其中的文件视图以及文件视图构成的文件目录系统\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/pad_img/1682738644666.jpg)\r\n\r\n针对于此篇内容，分成三部分来叙述，分别是**IO设备、磁盘、文件目录系统**的形成原理,其大致关系如下图\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071047204.jpg)\r\n\r\n## IO设备\r\n主要分为输入设备键盘以及输出设备显示器来进行描述\r\n\r\n**硬件介绍及视图引出**\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071049656.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071050524.jpg)\r\n\r\n**如何操纵外设**\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071051532.jpg)\r\n\r\n**文件视图层级结构**\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071052561.jpg)\r\n\r\n#### 输出设备显示器\r\n 执行过程以及总结如下\r\n- 输出执行过程\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055945.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055743.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055234.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055734.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055030.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055261.jpg)\r\n- 显示器输出总结\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071055490.jpg)\r\n\r\n#### 输入设备键盘\r\n键盘输入执行流程如下\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071059659.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071100321.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071100530.jpg)\r\n\r\n#### IO总结\r\nIO最终读写过程如下图\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071100626.jpg)\r\n## 磁盘\r\n\r\n#### 磁盘介绍\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071102956.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071102611.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071102963.jpg)\r\n\r\n#### 生磁盘(直接使用磁盘)\r\n- 根据CHS直接使用磁盘\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071102369.jpg)\r\n- 一层抽象，通过block号计算CHS来使用磁盘\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103202.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103513.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103969.jpg)\r\n\r\n- 二层抽象，为了配合多进程，通过队列使用磁盘\r\n\r\n**概念**\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103841.jpg)\r\n\r\n**调度算法**\r\n\r\n1. **FCFS**\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103958.jpg)\r\n2. **SSTF**\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103093.jpg)\r\n3. **SCAN**\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071103311.jpg)\r\n4. **电梯算法(C-SCAN)**\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071104581.jpg)\r\n\r\n- 生磁盘使用总结\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071104533.jpg)\r\n\r\n#### 熟磁盘(通过文件视图使用磁盘)\r\n\r\n- 第三层抽象,引入文件视图\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071105751.jpg)\r\n- 映射的作用(连续结构实现映射)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071105004.jpg)\r\n- 链式结构实现映射\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071106856.jpg)\r\n- 索引结构实现映射\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071106327.jpg)\r\n- 实际系统采用的结构\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071106993.jpg)\r\n\r\n#### file_write实际工作过程（代码介绍）\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071108226.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071119513.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071119245.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071119133.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071119325.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071125183.jpg)\r\n\r\n## 文件视图使用总结\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071120251.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071120468.jpg)\r\n\r\n## 文件目录系统\r\n为了方便文件的使用，引入了文件目录系统，更加完善了文件视图，构成拥有目录系统的完整文件视图，让其对用户使用显得更加友好方便\r\n\r\n#### 概念引入\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071124660.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071124951.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071124946.jpg)\r\n\r\n#### 演变过程\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071124382.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071125238.jpg)\r\n\r\n#### 如何实现目录\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071125233.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071125550.jpg)\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071125812.jpg)\r\n\r\n## 完整文件视图之下的磁盘使用\r\n在将硬件完全抽象成完整的文件视图(**包含目录的完整的文件视图，将整个磁盘全部抽象**)之后，磁盘的使用过程\r\n\r\n![](https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305071125861.jpg)','2023-05-07 11:33:39','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305022216346.jpg','原创',_binary '',_binary '\0',_binary '\0','哈工大操作系统v0.7-文件视图','2023-05-07 11:42:50','121',48,2,'操作系统中的文件目录系统的实现以及相关文件视图的内容，包括IO设备，磁盘等如何抽象得到文件视图',1),(18,_binary '\0',_binary '','## 题意\r\n给你一个链表数组，每个链表都已经按升序排列。\r\n\r\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\r\n\r\n## 示例\r\n```apache\r\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\r\n输出：[1,1,2,3,4,4,5,6]\r\n解释：链表数组如下：\r\n[\r\n  1->4->5,\r\n  1->3->4,\r\n  2->6\r\n]\r\n将它们合并到一个有序链表中得到。\r\n1->1->2->3->4->4->5->6\r\n```\r\n\r\n## 思路\r\n1. 优先级队列\r\n	时间复杂度：O(n∗log(k))O(n*log(k))O(n∗log(k))，n 是所有链表中元素的总和，k 是链表个数。\r\n2. 分而治之\r\n	链表两两合并\r\n\r\n## 代码\r\n- cpp\r\n\r\n**优先级队列**\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\r\n        priority_queue<ListNode*,vector<ListNode*>,function<bool(ListNode*, ListNode*)>> heap([](ListNode* L1,ListNode* L2){\r\n            return L1->val >= L2->val;\r\n        });\r\n\r\n        ListNode* res = new ListNode;\r\n        ListNode* tail = res;\r\n        for(auto i : lists){\r\n            if(i != nullptr){\r\n                heap.push(i);\r\n            }\r\n        } \r\n\r\n        while(!heap.empty()){\r\n            tail->next = heap.top();\r\n            heap.pop();\r\n            tail = tail->next;\r\n            if(tail->next)\r\n                heap.push(tail->next);\r\n        }\r\n\r\n        return res->next;\r\n    }\r\n};\r\n```\r\n\r\n**分而治之**\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\r\n        if(lists.size() == 0)\r\n            return nullptr;\r\n        return merge(0,lists.size()-1,lists);\r\n    }\r\n\r\n    ListNode* merge(int left,int right,vector<ListNode*>& lists){\r\n        if(left >= right)\r\n            return lists[left];\r\n        int mid = (left+right) / 2;\r\n        ListNode* leftNode = merge(left,mid,lists);\r\n        ListNode* rightNode = merge(mid+1,right,lists);\r\n        return dfs(leftNode,rightNode);\r\n    }\r\n\r\n    ListNode* dfs(ListNode* left,ListNode* right){\r\n        if(left == nullptr)\r\n            return right;\r\n        if(right == nullptr)\r\n            return left;\r\n        if(left->val < right->val){\r\n            left->next = dfs(left->next,right);\r\n            return left;\r\n        }\r\n        else{\r\n            right->next = dfs(left,right->next);\r\n            return right;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n\r\n**优先级队列**\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        if(lists.length == 0)\r\n            return null;\r\n        PriorityQueue<ListNode> heap = new PriorityQueue<>((L1,L2) -> L1.val - L2.val);\r\n\r\n        ListNode res = new ListNode();\r\n        ListNode tail = res;\r\n        for(ListNode i : lists){\r\n            if(i != null){\r\n                heap.add(i);\r\n            }\r\n        } \r\n\r\n        while(heap.isEmpty() == false){\r\n            tail.next = heap.poll();\r\n            tail = tail.next;\r\n            if(tail.next != null)\r\n                heap.add(tail.next);\r\n        }\r\n\r\n        return res.next;\r\n    }\r\n}\r\n```\r\n\r\n**分而治之**\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        if(lists.length == 0)\r\n            return null;\r\n        return merge(0,lists.length-1,lists);\r\n    }\r\n\r\n    ListNode merge(int left,int right,ListNode[] lists){\r\n        if(left >= right)\r\n            return lists[left];\r\n        int mid = (left+right) / 2;\r\n        ListNode leftNode = merge(left,mid,lists);\r\n        ListNode rightNode = merge(mid+1,right,lists);\r\n        return dfs(leftNode,rightNode);\r\n    }\r\n\r\n    ListNode dfs(ListNode left,ListNode right){\r\n        if(left == null)\r\n            return right;\r\n        if(right == null)\r\n            return left;\r\n        if(left.val < right.val){\r\n            left.next = dfs(left.next,right);\r\n            return left;\r\n        }\r\n        else{\r\n            right.next = dfs(left,right.next);\r\n            return right;\r\n        }\r\n    }\r\n}\r\n```','2023-05-21 10:06:15','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1684634742838.jpeg','原创',_binary '',_binary '',_binary '\0','leetcode 23. 合并 K 个升序链表','2023-06-25 21:35:42','92',50,2,'合并k个链表，其中的归并思想和优先级队列的设置值得反复复习,其中合并两个链表的递归方法也是个很好的方法，值得好好参考',0),(19,_binary '\0',_binary '','## 题目描述\r\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\r\n\r\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\r\n\r\n```apache\r\n示例\r\n输入: nums = [0,1,0,3,12]\r\n输出: [1,3,12,0,0]\r\n```\r\n\r\n## 题解\r\n**方法一：双指针**\r\n**思路及解法**\r\n\r\n1. 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。\r\n\r\n2. 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。\r\n\r\n注意到以下性质：\r\n- 左指针左边均为非零数；\r\n- 右指针左边直到左指针处均为零。\r\n- 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。\r\n\r\n## 代码\r\n\r\n- c++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    void moveZeroes(vector<int>& nums) {\r\n        int n = nums.size();\r\n        int left = 0,right = 0;\r\n        while(right < n){\r\n            if(nums[right]){\r\n                swap(nums[left],nums[right]);\r\n                left++;\r\n            }\r\n            right++;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    public void moveZeroes(int[] nums) {\r\n        int n = nums.length, left = 0, right = 0;\r\n        while (right < n) {\r\n            if (nums[right] != 0) {\r\n                swap(nums, left, right);\r\n                left++;\r\n            }\r\n            right++;\r\n        }\r\n    }\r\n\r\n    public void swap(int[] nums, int left, int right) {\r\n        int temp = nums[left];\r\n        nums[left] = nums[right];\r\n        nums[right] = temp;\r\n    }\r\n}\r\n```\r\n\r\n','2023-06-25 21:10:03','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1684634749007.jpeg','原创',_binary '',_binary '\0',_binary '\0','leetcode283. 移动零','2023-06-25 21:10:03','38',50,2,'此题包含伴随双指针的用法，值得反复揣摩。',0),(20,_binary '\0',_binary '','## 题目\r\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\r\n\r\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\r\n\r\n你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。\r\n\r\n```apache\r\n示例 1：\r\n\r\n输入：nums = [1,3,4,2,2]\r\n输出：2\r\n```\r\n\r\n## 题解\r\n使用环形链表II的方法解题（142.环形链表II），使用 142 题的思想来解决此题的关键是要理解如何将输入的数组看作为链表。 首先明确前提，整数的数组 nums 中的数字范围是 [1,n]。考虑一下两种情况：\r\n\r\n- 如果数组中没有重复的数，以数组 [1,3,4,2]为例，我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)f(n)f(n)， 其映射关系 n->f(n)为： 0->1 1->3 2->4 3->2 我们从下标为 0 出发，根据 f(n)f(n)f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。这样可以产生一个类似链表一样的序列。 0->1->3->2->4->null\r\n\r\n- 如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)f(n)f(n)， 其映射关系 n->f(n) 为： 0->1 1->3 2->4 3->2 4->2 同样的，我们从下标为 0 出发，根据 f(n)f(n)f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。 0->1->3->2->4->2->4->2->…… 这里 2->4 是一个循环，那么这个链表可以抽象为下图：\r\n\r\n![题解](https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png)\r\n\r\n从理论上讲，数组中如果有重复的数，那么就会产生多对一的映射，这样，形成的链表就一定会有环路了，\r\n\r\n综上 1.数组中有一个重复的整数 <==> 链表中存在环 2.找到数组中的重复整数 <==> 找到链表的环入口\r\n\r\n至此，问题转换为 142 题。那么针对此题，快、慢指针该如何走呢。根据上述数组转链表的映射关系，可推出 142 题中慢指针走一步 slow = slow.next ==> 本题 slow = nums[slow] 142 题中快指针走两步 fast = fast.next.next ==> 本题 fast = nums[nums[fast]]\r\n\r\n## 代码\r\n\r\n- c++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int findDuplicate(vector<int>& nums) {\r\n        int slow = 0,fast = 0;\r\n        do{\r\n            slow = nums[slow];\r\n            fast = nums[nums[fast]];\r\n        }while(slow != fast);\r\n        slow = 0;\r\n        do{\r\n            slow = nums[slow];\r\n            fast = nums[fast];\r\n        }while(slow != fast);\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    public int findDuplicate(int[] nums) {\r\n        int slow = 0,fast = 0;\r\n        do{\r\n            slow = nums[slow];\r\n            fast = nums[nums[fast]];\r\n        }while(slow != fast);\r\n        slow = 0;\r\n        do{\r\n            slow = nums[slow];\r\n            fast = nums[fast];\r\n        }while(slow != fast);\r\n        return slow;\r\n    }\r\n}\r\n```','2023-06-25 21:31:05','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1687699236884.jpg','原创',_binary '',_binary '',_binary '\0','leetcode287. 寻找重复数','2023-06-25 21:33:47','39',50,2,'此题主要是将数组中重复的元素的寻找，抽象转化成数组索引的环形链表里面环的入口，将索引抽象成链表，从而在链表里面，重复的索引形成了环，便可以使用快慢双指针来寻找环的入口，即寻找到对应的重复的值。',0),(21,_binary '\0',_binary '','## 题目\r\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\r\n\r\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\r\n\r\n你可以认为每种硬币的数量是无限的。\r\n\r\n```apache\r\n示例\r\n输入：coins = [1, 2, 5], amount = 11\r\n输出：3 \r\n解释：11 = 5 + 5 + 1\r\n```\r\n\r\n## 题解\r\n**解题思路：**\r\n\r\n1. **这种找路径，找方法的题一般可以使用回溯法来解决，回溯法也可以说是树形图法，解题的时候使用类似于树状图的结构，使用 自顶而下(也可以自下而上，但是自顶而下可以在后续优化成记忆化搜索提高效率) 的方法。**\r\n\r\n2. **而在回溯法中，如果含有很多的重复的计算的时候，就可以使用记忆化的搜索，将可能出现的重复计算大状态使用一个数组来保存其值，在进行重复的计算的时候，就可以直接的调用数组中的值，较少了不必要的递归。**\r\n\r\n3. **使用了记忆化搜索后，一般还可以进行优化，在记忆化搜索的基础上，变成 自底而上 的动态规划。**\r\n\r\n![](https://pic.leetcode-cn.com/2cdf411d73e7f4990c63c9ff69847c146311689ebc286d3eae715fa5c53483cf-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-03-08%2010.23.03.png)\r\n\r\n### 递归\r\n使用递归的关键是知道递归函数是用来干什么的，从宏观的角度去理解递归。 直接使用递归超出时间限制。\r\n\r\n```java\r\nclass Solution {\r\n    int res = Integer.MAX_VALUE;\r\n    public int coinChange(int[] coins, int amount) {\r\n        if(coins.length == 0){\r\n            return -1;\r\n        }\r\n\r\n        findWay(coins,amount,0);\r\n\r\n        // 如果没有任何一种硬币组合能组成总金额，返回 -1。\r\n        if(res == Integer.MAX_VALUE){\r\n            return -1;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public void findWay(int[] coins,int amount,int count){\r\n        if(amount < 0){\r\n            return;\r\n        }\r\n        if(amount == 0){\r\n            res = Math.min(res,count);\r\n        }\r\n\r\n        for(int i = 0;i < coins.length;i++){\r\n            findWay(coins,amount-coins[i],count+1);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 记忆化搜索\r\n\r\n![](https://pic.leetcode-cn.com/32128c822b67e7a851e78165e4498d71519c5ba7c1476e60f7d9e8c2df7487b0-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-03-08%2010.33.52.png)\r\n\r\n- 可以看出在进行递归的时候，有很多重复的节点要进行操作，这样会浪费很多的时间。 使用数组 memo[] 来保存节点的值memo[n]表示钱币n可以被换取的最少的硬币数，不能换取就为 −1 , findWay 函数的目的是为了找到 amount 数量的零钱可以兑换的最少硬币数量，返回其值 int\r\n\r\n- 在进行递归的时候，memo[n]被复制了，就不用继续递归了，可以直接的调用。\r\n\r\n```java\r\nclass Solution {\r\n    int[] memo;\r\n    public int coinChange(int[] coins, int amount) {\r\n        if(coins.length == 0){\r\n            return -1;\r\n        }\r\n        memo = new int[amount];\r\n\r\n        return findWay(coins,amount);\r\n    }\r\n    // memo[n] 表示钱币n可以被换取的最少的硬币数，不能换取就为-1\r\n    // findWay函数的目的是为了找到 amount数量的零钱可以兑换的最少硬币数量，返回其值int\r\n    public int findWay(int[] coins,int amount){\r\n        if(amount < 0){\r\n            return -1;\r\n        }\r\n        if(amount == 0){\r\n            return 0;\r\n        }\r\n        // 记忆化的处理，memo[n]用赋予了值，就不用继续下面的循环\r\n        // 直接的返回memo[n] 的最优值\r\n        if(memo[amount-1] != 0){\r\n            return memo[amount-1];\r\n        }\r\n        int min = Integer.MAX_VALUE;\r\n        for(int i = 0;i < coins.length;i++){\r\n            int res = findWay(coins,amount-coins[i]);\r\n            if(res >= 0 && res < min){\r\n                min = res + 1; // 加1，是为了加上得到res结果的那个步骤中，兑换的一个硬币\r\n            }\r\n        }\r\n        memo[amount-1] = (min == Integer.MAX_VALUE ? -1 : min);\r\n        return memo[amount-1];\r\n    }\r\n}\r\n```\r\n\r\n### 动态规划\r\n1. 上面的记忆化搜索是先从 **memo[amonut−1]** 开始，从上到下 动态规划从 **memo[0]** 开始，从下到上\r\n2. 转移方程 **dp[n] = min{dp[n-i]+1 for i in coins if n-i >= 0 && dp[n-i] != -1}**\r\n\r\n- c++\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int coinChange(vector<int>& coins, int amount) {\r\n        vector<int> dp(amount+1,-1);\r\n        dp[0] = 0;\r\n        for(int i = 1;i <= amount;i++){\r\n            for(int j : coins){\r\n                if(i - j >= 0 && dp[i-j] != -1){\r\n                    if(dp[i] == -1)\r\n                        dp[i] = dp[i-j] + 1;\r\n                    else\r\n                        dp[i] = min(dp[i-j]+1,dp[i]);\r\n                }\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n};\r\n```\r\n\r\n- java\r\n```java\r\nclass Solution {\r\n    public int coinChange(int[] coins, int amount) {\r\n        int[] dp = new int[amount+1];\r\n        Arrays.fill(dp,-1);\r\n        dp[0] = 0;\r\n        for(int i = 1;i <= amount;i++){\r\n            for(int j : coins){\r\n                if(i - j >= 0 && dp[i-j] != -1){\r\n                    if(dp[i] == -1)\r\n                        dp[i] = dp[i-j] + 1;\r\n                    else\r\n                        dp[i] = Math.min(dp[i-j]+1,dp[i]);\r\n                }\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n}\r\n```','2023-07-06 20:54:33','https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1688649063189.jpg','原创',_binary '',_binary '',_binary '\0','leetcode 322. 零钱兑换','2023-07-06 21:11:32','36',50,2,'此题里面蕴含着寻找路径，寻找解决方法的题目的通用解决方法，本文分别对递归解决，记忆化搜索解决，动态规划解决等三种方法做出解析以及说明对比，方便后续进行回顾复习。',0);
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog_tags`
--

DROP TABLE IF EXISTS `t_blog_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint NOT NULL AUTO_INCREMENT,
  `tags_id` bigint NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`) USING BTREE,
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`) USING BTREE
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb3 ROW_FORMAT=FIXED;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog_tags`
--

LOCK TABLES `t_blog_tags` WRITE;
/*!40000 ALTER TABLE `t_blog_tags` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_blog_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `blog_id` bigint DEFAULT NULL,
  `parent_comment_id` bigint DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
INSERT INTO `t_comment` VALUES (1,'shari','2228322703@qq.com','牛蛙','/images/avatar.png','2023-04-10 13:38:52',1,-1,_binary '\0'),(2,'maple','1910046133@qq.com','牛蛙','/images/me.jpg','2023-04-10 17:59:00',1,1,_binary ''),(3,'maple','1910046133@qq.com','死锁的有关概念和临界区的有关概念，较为重要，需要牢记','/images/me.jpg','2023-05-03 20:44:01',13,-1,_binary ''),(4,'111','136183196@qq.com','大佬666','/images/avatar.png','2023-05-07 11:53:09',17,-1,_binary '\0');
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_friend`
--

DROP TABLE IF EXISTS `t_friend`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_friend` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `blogaddress` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `blogname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `pictureaddress` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=92 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_friend`
--

LOCK TABLES `t_friend` WRITE;
/*!40000 ALTER TABLE `t_friend` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_friend` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_memory`
--

DROP TABLE IF EXISTS `t_memory`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_memory` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL,
  `picture_address` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `memory` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_memory`
--

LOCK TABLES `t_memory` WRITE;
/*!40000 ALTER TABLE `t_memory` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_memory` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_message`
--

DROP TABLE IF EXISTS `t_message`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_message` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `parent_message_id` bigint DEFAULT NULL,
  `admin_message` bit(1) NOT NULL,
  `parent_email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=8136 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_message`
--

LOCK TABLES `t_message` WRITE;
/*!40000 ALTER TABLE `t_message` DISABLE KEYS */;
INSERT INTO `t_message` VALUES (8132,'滴答滴答','136183196@qq.com','街边来来往往皆是车辆与路人，大家或是行色匆匆，或是悠闲踱步，或是准备赴一场令人怦然心动的约会。\n\n \n\n只不过是一个微不足道的生命消失了而已。\n\n \n\n阳光，树叶，微风，喧嚣。\n\n \n\n世界并无变化，一切如常。','/images/avatar.png','2023-04-09 23:49:48',-1,_binary '\0',NULL),(8133,'Anchor','3520279471@qq.com','心若向阳花自盛开，人若向暖清风徐来。','/images/avatar.png','2023-04-10 15:38:40',-1,_binary '\0',NULL),(8134,'maplesong','1910046133@qq.com','有品','/images/avatar.png','2023-04-10 15:48:44',8133,_binary '\0',NULL),(8135,'maple','1910046133@qq.com','有东西','/images/me.jpg','2023-04-10 17:59:31',8132,_binary '',NULL);
/*!40000 ALTER TABLE `t_message` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_picture`
--

DROP TABLE IF EXISTS `t_picture`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_picture` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `pictureaddress` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `picturedescription` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `picturename` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `picturetime` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=71 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_picture`
--

LOCK TABLES `t_picture` WRITE;
/*!40000 ALTER TABLE `t_picture` DISABLE KEYS */;
INSERT INTO `t_picture` VALUES (59,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282148616.jpg','school','生活','2023.4.28'),(60,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282148678.jpg','home','生活','2023.4.28'),(61,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282147530.jpg','熏儿','熏儿','2023.4.28'),(62,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304302240402.jpeg','熏儿','熏儿','2023.4.30'),(63,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202304282147110.png','熏儿','熏儿','2023.4.30'),(64,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/blog_img/202305011831734.jpg','熏儿','熏儿','2023.5.1'),(65,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1687699236884.jpg','月婵','月婵','2023.6.25'),(66,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1687699229046.jpg','月婵','月婵','2023.6.25'),(67,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1684634742838.jpeg','雪琪','雪琪','2023.6.25'),(68,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1687699248747.webp','雪琪','雪琪','2023.6.25'),(69,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1688649063189.jpg','彦','彦','2023.7.6'),(70,'https://cdn.jsdelivr.net/gh/Maplessw/picgo_image/phone_img/1688649417645.jpg','彦','彦','2023.7.6');
/*!40000 ALTER TABLE `t_picture` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_resources`
--

DROP TABLE IF EXISTS `t_resources`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_resources` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `resource_name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `resource_address` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `first_type` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `second_type` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `picture_address` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `resource_description` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `sort` int unsigned DEFAULT '0',
  `published` tinyint(1) unsigned zerofill NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=472 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_resources`
--

LOCK TABLES `t_resources` WRITE;
/*!40000 ALTER TABLE `t_resources` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_resources` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_tag`
--

DROP TABLE IF EXISTS `t_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_tag`
--

LOCK TABLES `t_tag` WRITE;
/*!40000 ALTER TABLE `t_tag` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_type`
--

DROP TABLE IF EXISTS `t_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_type` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=51 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_type`
--

LOCK TABLES `t_type` WRITE;
/*!40000 ALTER TABLE `t_type` DISABLE KEYS */;
INSERT INTO `t_type` VALUES (43,'生活'),(44,'git操作'),(45,'java基础'),(46,'运维'),(47,'剑指offer'),(48,'操作系统'),(49,'数据结构与算法'),(50,'leetcode');
/*!40000 ALTER TABLE `t_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `type` int DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (2,'/images/me.jpg','2023-04-09 19:48:13','1910046133@qq.com','maple','33aea09a815c03824640fdd3e5a80e9d',1,'2023-04-09 19:48:13','maple');
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-07-18 16:05:50
